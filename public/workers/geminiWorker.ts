// Web Worker for Gemini AI service to offload heavy processing from main thread

// Define constants inline to avoid import issues in worker context
const MQL5_SYSTEM_PROMPT = `
You are an expert MQL5 (MetaTrader 5) programmer and quantitative trading strategist.
Your task is to generate complete, functional MQL5 trading robot code based on user requirements.
`;

// Define types inline to avoid import issues in worker context
interface StrategyParams {
  symbol: string;
  timeframe: string;
  riskPercent: number;
  stopLoss: number;
  takeProfit: number;
  magicNumber: number;
  customInputs: Array<{
    type: 'string' | 'number' | 'boolean';
    name: string;
    value: string | number | boolean;
  }>;
}

interface StrategyAnalysis {
  riskScore: number;
  profitability: number;
  description: string;
  recommendations?: string[];
}

interface Message {
  id: string;
  role: 'user' | 'model' | 'system';
  content: string;
  timestamp: number;
  thinking?: string | null;
}

// Worker message types
interface GenerateMessage {
  type: 'generate';
  payload: StrategyParams;
  id: string;
}

interface AnalyzeMessage {
  type: 'analyze';
  payload: { code: string };
  id: string;
}

type WorkerMessage = GenerateMessage | AnalyzeMessage;

interface GenerateSuccessResponse {
  type: 'success';
  payload: string;
  id: string;
}

interface AnalyzeSuccessResponse {
  type: 'success';
  payload: StrategyAnalysis;
  id: string;
}

interface ErrorResponse {
  type: 'error';
  payload: { message: string };
  id: string;
}

type WorkerResponse = GenerateSuccessResponse | AnalyzeSuccessResponse | ErrorResponse;

// Handle messages from main thread with origin validation
self.addEventListener('message', async (event: MessageEvent<WorkerMessage>) => {
  // Validate origin - only accept messages from same origin
  if (event.origin && event.origin !== self.location.origin) {
    console.warn(`Rejected message from unauthorized origin: ${event.origin}`);
    return;
  }

  // Validate data structure
  if (!event.data || typeof event.data !== 'object') {
    console.warn('Rejected message: invalid data structure');
    return;
  }

  const { type, payload, id } = event.data;

  // Validate required fields
  if (!type || !id) {
    console.warn('Rejected message: missing required fields (type or id)');
    return;
  }

  try {
    switch (type) {
      case 'generate':
        const generatedCode = await generateStrategy(payload);
        self.postMessage({
          type: 'success',
          payload: generatedCode,
          id
        } as WorkerResponse);
        break;

      case 'analyze':
        const analysis = await analyzeStrategy(payload.code);
        self.postMessage({
          type: 'success',
          payload: analysis,
          id
        } as WorkerResponse);
        break;

      default:
        throw new Error(`Unknown worker message type: ${type}`);
    }
  } catch (error: unknown) {
    self.postMessage({
      type: 'error',
      payload: {
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      id
    } as WorkerResponse);
  }
});

// Generate MQL5 strategy code
async function generateStrategy(params: StrategyParams): Promise<string> {
  // Simulate AI generation (in production, this would call the actual AI service)
  const { symbol, timeframe, riskPercent, stopLoss, takeProfit } = params;
  
  return `
//+------------------------------------------------------------------+
//|                                                 QuantForge_${symbol}_${timeframe}.mq5 |
//|                                    Generated by QuantForge AI ${new Date().toISOString()} |
//+------------------------------------------------------------------+
#property copyright "QuantForge AI"
#property version   "1.0"

input double RiskPercent = ${riskPercent};
input double StopLoss = ${stopLoss};
input double TakeProfit = ${takeProfit};
input int MagicNumber = 12345;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit() {
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick() {
   // Strategy logic implementation would go here
   // This is a simplified template
}
`;
}

// Analyze existing strategy
async function analyzeStrategy(code: string): Promise<StrategyAnalysis> {
  // Simulate strategy analysis
  await new Promise(resolve => setTimeout(resolve, 500)); // Simulate processing time
  
  return {
    riskScore: Math.random() * 100,
    profitability: Math.random() * 100,
    description: 'Strategy analysis completed in worker thread',
    recommendations: [
      'Consider adding proper risk management',
      'Implement position sizing based on account balance',
      'Add trailing stop functionality'
    ]
  };
}

export {};